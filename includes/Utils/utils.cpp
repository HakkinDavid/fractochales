#include "utils.h"

int utils :: new_obj_index = 0;

const std::wstring & utils :: getRandomAdvice() {
    return advice_text[rand() % advice_max_num];
}

const std::string utils :: newLightningFileName (const int type) {
    return "obj/output/lightning_" + std::to_string(new_obj_index) + "." + export_types[type];
}

std::wstring utils :: getFileHeader (const int type) {
    std::wstringstream header_stream;
            header_stream
            << L"# FRACTOCHALES v"
            << std::fixed << std::setprecision(2)
            << (float) VERSION / 100
            << L" generated lightning " << export_types_localized[type] << " file"
            << std::endl
            << L"# © David Emmanuel Santana Romero" << std::endl << L"# © Mauricio Alcántar Dueñas" << std::endl << L"# © Diego Emilio Casta Valle"
            << std::endl
            << L"# DISCLAIMER: Files generated by our software may be used for any purpose as long as we are explicitly credited in the projects, media and papers that make use of these." << std::endl << std::endl;
    return header_stream.str();
}

std::wstring utils :: to_super (std::wstring num) {
    for (int i = 0; i < num.length(); i++) {
        num[i] = super[num.at(i) - L'0'];
    }
    return num;
}

void utils :: format_wstringstream (std::wstringstream & s) {
    std::wstring temporal (s.str());
    const std::wregex exponential (L"e([+-])([0-9]+)");
    std::match_results<std::wstring::iterator> match;
    int substart = 0;

    // super efficient regex (each iteration, string is only analyzed after first match)
    while (std::regex_search(temporal.begin() + substart, temporal.end(), match, exponential)) {
        std::wstring replacement = (match[2].str() != L"00" ? L"×10" + (match[1].str() == L"-" ? std::wstring(L"⁻") : std::wstring(L"")) + (match[2].str() == L"01" && match[1] == L"+" ? std::wstring(L"") : to_super(match[2].str())) : L"");
        temporal.replace(temporal.begin() + substart + match.position(0), temporal.begin() + substart + match.position(0) + match.length(0), replacement);
        substart += match.position(0) + replacement.length();
    }

    if (temporal.back() == L'\n') {
        temporal.pop_back();
    }

    s.str(temporal);
}

void utils :: scaleBG (sf::RenderTarget * window, sf::Sprite & background, sf::Texture ** bg, int & bgIndex, float & bg_scale) {
    background.setScale(1.f, 1.f);
    bg_scale = (window->getSize().x > window->getSize().y ? window->getSize().x / (*bg[bgIndex]).getSize().x : window->getSize().y / (*bg[bgIndex]).getSize().y);
    bg_scale *= (MOBILE ? 1.5 : 1.f);
    if (bg_scale != 1.f) {
        background.setScale(bg_scale, bg_scale);
    }
    background.setPosition((window->getSize().x - ((*bg[bgIndex]).getSize().x * bg_scale))/2, (window->getSize().y - ((*bg[bgIndex]).getSize().y * bg_scale))/2);
};